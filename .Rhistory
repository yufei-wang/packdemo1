}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
ggplot(data = cv.err,
aes(x = factor(k), y = mse)) +
geom_boxplot(fill = factor(k)) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE",
fill = "Number of Folds") +
theme_bw(base_size = 20)
#
library(randomForest)
library(ggplot2)
library(gapminder)
my_rf_cv <- function(k){
set.seed(229)
n <- nrow(gapminder)
fold <- sample(rep(1:k, length = n))
data <- data.frame(gapminder, "split" = fold)
cv_err_vec <- rep(NA, k)
for (i in 1:k) {
data_train <- data %>% dplyr::filter(split != i)
data_test <- data %>% dplyr::filter(split == i)
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 100)
prediction <- predict(model, data_test[, -1])
cv_err_vec[i] = mean((data_test$lifeExp - prediction)^2)
}
cv_err <- mean(cv_err_vec)
return(cv_err)
}
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, 30)
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[i, 2] <- my_rf_cv(k) %>% round(5)
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
cv.err
library(randomForest)
library(ggplot2)
library(gapminder)
my_rf_cv <- function(k){
set.seed(229)
n <- nrow(gapminder)
fold <- sample(rep(1:k, length = n))
data <- data.frame(gapminder, "split" = fold)
cv_err_vec <- rep(NA, k)
for (i in 1:k) {
data_train <- data %>% dplyr::filter(split != i)
data_test <- data %>% dplyr::filter(split == i)
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 100)
prediction <- predict(model, data_test[, -1])
cv_err_vec[i] = mean((data_test$lifeExp - prediction)^2)
}
cv_err <- mean(cv_err_vec)
return(cv_err)
}
#create matrix to store cv error
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(c(2, 5, 10), 30)
j = 1
#Iterate through k in c(2, 5, 10):
for(k in c(2, 5, 10)) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k) %>% round(5)
j = j +1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
cv.err
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE")
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE", fill = factor(k)) +
ylim(c(0,100))
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE", fill = factor(k)) +
ylim(c(70,80))
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot() +
labs(title = "MSE for K folds", x = "Number of Folds", y = "MSE",
fill = "Number of Folds") +
theme_classic(base_size = 18) +
theme(plot.title = element_text(hjust = 0.5),
panel.background = element_rect(fill = "floralwhite"),
legend.title = element_text(hjust = 0.5, size = 15),
legend.margin = margin(6, 6, 6, 6))
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(fill = "cornflowerflue") +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(fill = "cornflowerblue") +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
cv.err
library(randomForest)
library(ggplot2)
library(gapminder)
my_rf_cv <- function(k){
set.seed(229)
n <- nrow(gapminder)
fold <- sample(rep(1:k, length = n))
data <- data.frame(gapminder, "split" = fold)
cv_err_vec <- rep(NA, k)
for (i in 1:k) {
data_train <- data %>% dplyr::filter(split != i)
data_test <- data %>% dplyr::filter(split == i)
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 100)
prediction <- predict(model, data_test[, -1])
cv_err_vec[i] = mean((data_test$lifeExp - prediction)^2)
}
cv_err <- mean(cv_err_vec)
return(cv_err)
}
#create matrix to store cv error
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(c(2, 5, 10), 30)
j = 1
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
for(i in 1:30) {
for(k in c(2, 5, 10)) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k) %>% round(5)
j = j +1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
cv.err
library(randomForest)
library(ggplot2)
library(gapminder)
my_rf_cv <- function(k){
set.seed(229)
n <- nrow(gapminder)
fold <- sample(rep(1:k, length = n))
data <- data.frame(gapminder, "split" = fold)
cv_err_vec <- rep(NA, k)
for (i in 1:k) {
data_train <- data %>% dplyr::filter(split != i)
data_test <- data %>% dplyr::filter(split == i)
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 100)
prediction <- predict(model, data_test[, -1])
cv_err_vec[i] = mean((data_test$lifeExp - prediction)^2)
}
cv_err <- mean(cv_err_vec)
return(cv_err)
}
#create matrix to store cv error
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(c(2, 5, 10), 30)
j = 1
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
for(i in 1:30) {
for(k in c(2, 5, 10)) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k) %>% round(5)
j = j +1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
cv.err
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(fill = "cornflowerblue") +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
my_rf_cv111 <- function(k) {
# generates an error if the input k is not numeric
if (!is.numeric(k)) {
stop("K must be numeric")
}
# randomly assigns observations to folds 1,…,k with equal probability
train <- my_gapminder %>% select(lifeExp, gdpPercap)
fold <- sample(rep(1:k, length = nrow(train)))
my_data <- train %>% mutate(fold = fold)
# evaluate MSE, the average squared difference between predicted
# Sepal.Length and true Sepal.Length.
mse <- rep(NA, k)
# loop through the folds
for (i in 1:k) {
# get the training data
data_train <- my_data %>% filter(fold != i) %>% select(-fold)
# get the test data
data_test <- my_data %>% filter(fold == i) %>% select(-fold)
# get the model
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 50)
# predict the life expentance of test data
# the second column is gdpPercap
pred <- predict(model, data_test[, 2])
# evaluate MSE, the average squared difference between predicted
# lifeExp and true lifeExp
mse[i] <- mean((pred - data_test$lifeExp)^2)
}
# return the average mse across all k folds
return(mean(mse))
}
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
#For each of the 30 iterations, store the CV estimated MSE.
cv_error <- matrix(NA, nrow = 90, ncol = 2)
cv_error[, 1] <- rep(c(2, 5, 10), each = 30)
# rows begin at 1
row <- 1
for(k in c(2, 5, 10)) {
for(i in 1:30) {
cv_error[row, 2] <- my_rf_cv11(k)
row <- row + 1
}
}
my_rf_cv11 <- function(k) {
# generates an error if the input k is not numeric
if (!is.numeric(k)) {
stop("K must be numeric")
}
# randomly assigns observations to folds 1,…,k with equal probability
train <- my_gapminder %>% select(lifeExp, gdpPercap)
fold <- sample(rep(1:k, length = nrow(train)))
my_data <- train %>% mutate(fold = fold)
# evaluate MSE, the average squared difference between predicted
# Sepal.Length and true Sepal.Length.
mse <- rep(NA, k)
# loop through the folds
for (i in 1:k) {
# get the training data
data_train <- my_data %>% filter(fold != i) %>% select(-fold)
# get the test data
data_test <- my_data %>% filter(fold == i) %>% select(-fold)
# get the model
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 50)
# predict the life expentance of test data
# the second column is gdpPercap
pred <- predict(model, data_test[, 2])
# evaluate MSE, the average squared difference between predicted
# lifeExp and true lifeExp
mse[i] <- mean((pred - data_test$lifeExp)^2)
}
# return the average mse across all k folds
return(mean(mse))
}
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
#For each of the 30 iterations, store the CV estimated MSE.
cv_error <- matrix(NA, nrow = 90, ncol = 2)
cv_error[, 1] <- rep(c(2, 5, 10), each = 30)
# rows begin at 1
row <- 1
for(k in c(2, 5, 10)) {
for(i in 1:30) {
cv_error[row, 2] <- my_rf_cv11(k)
row <- row + 1
}
}
my_rf_cv11 <- function(k) {
# generates an error if the input k is not numeric
if (!is.numeric(k)) {
stop("K must be numeric")
}
# randomly assigns observations to folds 1,…,k with equal probability
train <- gapminder %>% select(lifeExp, gdpPercap)
fold <- sample(rep(1:k, length = nrow(train)))
my_data <- train %>% mutate(fold = fold)
# evaluate MSE, the average squared difference between predicted
# Sepal.Length and true Sepal.Length.
mse <- rep(NA, k)
# loop through the folds
for (i in 1:k) {
# get the training data
data_train <- my_data %>% filter(fold != i) %>% select(-fold)
# get the test data
data_test <- my_data %>% filter(fold == i) %>% select(-fold)
# get the model
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 50)
# predict the life expentance of test data
# the second column is gdpPercap
pred <- predict(model, data_test[, 2])
# evaluate MSE, the average squared difference between predicted
# lifeExp and true lifeExp
mse[i] <- mean((pred - data_test$lifeExp)^2)
}
# return the average mse across all k folds
return(mean(mse))
}
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
#For each of the 30 iterations, store the CV estimated MSE.
cv_error <- matrix(NA, nrow = 90, ncol = 2)
cv_error[, 1] <- rep(c(2, 5, 10), each = 30)
# rows begin at 1
row <- 1
for(k in c(2, 5, 10)) {
for(i in 1:30) {
cv_error[row, 2] <- my_rf_cv11(k)
row <- row + 1
}
}
my_rf_cv11 <- function(k) {
# generates an error if the input k is not numeric
if (!is.numeric(k)) {
stop("K must be numeric")
}
# randomly assigns observations to folds 1,…,k with equal probability
train <- gapminder %>% select(lifeExp, gdpPercap)
fold <- sample(rep(1:k, length = nrow(train)))
my_data <- train %>% mutate(fold = fold)
# evaluate MSE, the average squared difference between predicted
# Sepal.Length and true Sepal.Length.
mse <- rep(NA, k)
# loop through the folds
for (i in 1:k) {
# get the training data
data_train <- my_data %>% filter(fold != i) %>% select(-fold)
# get the test data
data_test <- my_data %>% filter(fold == i) %>% select(-fold)
# get the model
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 50)
# predict the life expentance of test data
# the second column is gdpPercap
pred <- predict(model, data_test[, 2])
# evaluate MSE, the average squared difference between predicted
# lifeExp and true lifeExp
mse[i] <- mean((pred - data_test$lifeExp)^2)
}
# return the average mse across all k folds
return(mean(mse))
}
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
#For each of the 30 iterations, store the CV estimated MSE.
cv_error <- matrix(NA, nrow = 90, ncol = 2)
cv_error[, 1] <- rep(c(2, 5, 10), each = 30)
# rows begin at 1
row <- 1
for(k in c(2, 5, 10)) {
for(i in 1:30) {
cv_error[row, 2] <- my_rf_cv11(k)
row <- row + 1
}
}
my_df <- data.frame("k" = cv_error[, 1], "mse" = cv_error[, 2])
my_df
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, 30)
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[i, 2] <- my_rf_cv(k)
}
}
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, each = 30)
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[i, 2] <- my_rf_cv(k)
}
}
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, each = 30)
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k)
j = j + 1
}
}
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, each = 30)
j = 1
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k)
j = j + 1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
ggplot(data = cv.err,
aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE",
fill = "Number of Folds") +
theme_bw(base_size = 20) +
theme(plot.title = element_text(hjust = 0.5))
my_df %>%
ggplot(aes(x = factor(k), y = mse, fill = factor(k))) +
geom_boxplot() +
labs(title = "MSE for K folds", x = "Number of Folds", y = "MSE",
fill = "Number of Folds") +
theme_classic(base_size = 18) +
theme(plot.title = element_text(hjust = 0.5),
panel.background = element_rect(fill = "floralwhite"),
legend.title = element_text(hjust = 0.5, size = 15),
legend.margin = margin(6, 6, 6, 6))
cv.err
#create matrix to store cv error
k_val <- c(2, 5, 10)
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(k_val, each = 30)
j = 1
#Iterate through k in c(2, 5, 10):
for(k in k_val) {
#For each value of k, run your function 30 times.
for(i in 1:30) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv(k)
j = j + 1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
cv.err
ggplot(data = cv.err,
aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(alpha = 0.4) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE",
fill = "Number of Folds") +
theme_bw(base_size = 20) +
theme(plot.title = element_text(hjust = 0.5))
library(randomForest)
library(ggplot2)
library(gapminder)
my_rf_cv1 <- function(k){
n <- nrow(gapminder)
fold <- sample(rep(1:k, length = n))
data <- data.frame(gapminder, "split" = fold)
cv_err_vec <- rep(NA, k)
for (i in 1:k) {
data_train <- data %>% dplyr::filter(split != i)
data_test <- data %>% dplyr::filter(split == i)
model <- randomForest(lifeExp ~ gdpPercap, data = data_train, ntree = 100)
prediction <- predict(model, data_test[, -1])
cv_err_vec[i] = mean((data_test$lifeExp - prediction)^2)
}
cv_err <- mean(cv_err_vec)
return(cv_err)
}
#create matrix to store cv error
cv_err.mat <- matrix(NA, 90, 2)
cv_err.mat[, 1] <- rep(c(2, 5, 10), 30)
j = 1
#Iterate through k in c(2, 5, 10):
#For each value of k, run your function 30 times.
for(i in 1:30) {
for(k in c(2, 5, 10)) {
#For each of the 30 iterations, store the CV estimated MSE.
cv_err.mat[j, 2] <- my_rf_cv1(k) %>% round(5)
j = j +1
}
}
cv.err <- data.frame("k" = cv_err.mat[, 1], "mse" = cv_err.mat[, 2])
cv.err
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(fill = "cornflowerblue") +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot(fill = factor(k)) +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot() +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE") +
theme_bw(base_size = 20)
ggplot(data = cv.err, aes(x = factor(k), y = mse), fill = factor(k)) +
geom_boxplot() +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE",fill = "Number of Folds") +
theme_bw(base_size = 20)
ggplot(data = cv.err, aes(x = as.factor(k), y = mse), fill = as.factor(k)) +
geom_boxplot() +
labs(title = "Boxplots of MSE by k folds", x = "Number of Folds", y = "MSE", fill = "Number of Folds") +
theme_bw(base_size = 20)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(stat302package)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(stat302package)
devtools::install_github("yufei-wang/stat302package")
